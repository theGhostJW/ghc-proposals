- type-level Trace
- transcript files (including all instances used, etc.). Useful output for grepping.
- impredicative instantiation (see Slack call with Simon)
   (and mark ImpredicativeTypes as a bug)
- datatype declaration kind variables should be variables, not skolems
- VKA in LHsQTyVars
- narrowing exports (length :: [a] -> Int)
- -XNoImplicitForalls
- fix GADT syntax and implement kind inference for datatypes
- module ... of for order-dependent declarations
- syntax rules. See https://gitlab.haskell.org/ghc/ghc/issues/18139#note_270058
- Pattern-like variables in types. See https://gitlab.haskell.org/ghc/ghc/issues/16726#note_202987
  --> Problem. What if class C (a :: k) where meth :: a -> a; type F k = ... ? That's no good.
      So we'll have to have very special treatment in associated types to make sure this hasn't
      happened.

      New idea: allow only skolem-like variable in associated type family declarations.
- Change -XRankNTypes to -XNestedForAll: see #11540
- warning for abstract types without role annotations (from @taktoa on YouTube)
- mixing syntax for GADT constructors
- remove datacons from #81
- do something about Safe Haskell (#19129)
- rewriting Ã  la Cockx POPL'21 paper
- Remove -fdefer-type-errors in favor of just twiddling a warning flag.
- version numbers in Haskell files. or cabal files?
- strict tuples: (! ,,, !) vs (~ ,,, ~). And -XStrictTuple to change the default.
- absurd patterns. See https://github.com/ghc-proposals/ghc-proposals/pull/302#issuecomment-831342880   See also #423
------------------------------

clarify-modifiers:
  #392
  modifiers precede what they modify
  amendment to #370

bylaws:
  #360

dependent-types:
  ergonomic dependent types
  #378

higher-roles:
  #233
  needs a type safety proof

local-modules:
  #285
  
operators:
  warn on operators with insufficient whitespace
  #368
  amendment to #229

reordered-tyvars:
  allow tyvars to be out of dependency order: typeRep :: forall (a :: k) k. ...
  dormant
  #131

rich-errors-proposal:
  #306
  make ADTs for each error
  also GHC#18516.
  suggest to close.

type-abstractions:
  amendment to #155
  limits -XScopedTypeVariables
  #238

updated-partial-type-sigs:
  #194

no-dcvdq:
  #393
  strike `forall ->` from data constructors


-------------------------
Ideas for GHC 7.10
==================

1. `-XFlexibleNewtypes`

Newtypes currently must have exactly one constructor with exactly one field.
I propose liberalizing this to allow, instead of one field, one constraint.
Thus, the following would be acceptable:

{{{
newtype TypeOf a = Typeable a => MkTypeOf
}}}

We could then have the following Coercible instances:

{{{
instance Coercible a (Typeable b => c) => Coercible a (TypeOf b -> c)
instance Coercible (Typeable b => c) a => Coercible (TypeOf b -> c) a
}}}

2. <stricken>

3. Type pattern synonyms.

See #8828.

4. Deriving related instances.

I want the following to work:

{{{
class Monad m where
  return :: a -> m a
  (>>=) :: m a -> (a -> m b) -> m b

  deriving instance Functor m where
    fmap = ap  

  deriving instance Applicative m where
    pure = return
    (<*>) = ap
  -- additional constraints can be put on instances if needed

-- ...

instance Monad Maybe where
  return = Just
  Nothing >>= _  = Nothing
  (Just x) >>= f = f x

  deriving (Functor, Applicative)   -- these inherit the constraints and params above
  -- OR
  deriving instance Functor m
  deriving instance Applicative m   -- these specify constraints
}}}

Could also say "deriving default instance" in the class defn. Instance-writers who
omit the "deriving" and have no other relevant instance get one autmoatically, and
a warning.

5.

-XNoOrphans means that, for any class defined in the module, no orphan instances
can ever be written. With NoOrphans, OverlappingInstances becomes Safe, I think.

6.

A functioning version of ScopedTypeVariables. Currently, ScopedTypeVariables can
only ever be skolems. I wish to be able to use a scoped type variable to bind
a name to an inferred type. This becomes even more interesting with partial
type signatures.

7. <stricken>

8. Give a more restrictive type in an re-export list.

shachaf points out that importing a new module (with the more polymorphic type)
might now break instance inference. This is true. But is it so bad?

If we import (map :: Functor f => (a -> b) -> f a -> f b) from Data.Functor,
(map :: (a -> b) -> [a] -> [b]) from Data.List, and
(map :: (a -> b) -> Maybe a -> Maybe b) from Data.Maybe, what happens? Data.Functor
wins.

The types form a lattice. There is a conflict if a lub isn't imported.

shachaf: "It's pretty odd that "import Data.{Maybe,List}" gives an error but
"import Data.{Maybe,List,Functor}" doesn't." But the error only happens when
you use the identifier

carter: Think about fusing before getting rid of monomorphic implementations.
RAE: but this doesn't kill the idea, just makes it perhaps less applicable.

This proposal has been done before:
http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/23719

The general conclusion is that it adds significant complexity to the module
system just for the sake of helping novices. Perhaps there's a better way to
help novices more directly than by burdening the module system?

Strike?

9. Derive Monoid

10. TH.reportError should be :: String -> Q a, not String -> Q ().

11. An `import hiding ( ... )` declaration in an import list hides those identifiers
from *all* imports.

12. Injective type families.

13. MINIMAL should support associated type families.

14. concatMapM

15. (performance regression involving Desugar.Core?)

16. TH quotes should still succeed with unbound ids.
